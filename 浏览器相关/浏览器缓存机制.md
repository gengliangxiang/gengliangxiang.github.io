# 浏览器缓存机制

##

## 强制缓存

- 浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求
- 强缓存一般是这样一个流程：
  1. 查看 header 头中的 Expire 和 Cache-control 来判断是否满足规则；
  2. 如果满足规则，就返回缓存的数据；
  3. 如果不满足规则，就向服务器发送请求；
  4. 服务器返回数据；
  5. 将新数据存入缓存。

#### Expire

- expires 包含了一个时间，过了这个时间，响应将会失效
- GMT 表示的是格林威治时间，和北京时间相差 8 小时。
- 修改了客户端的本地时间,导致判断缓存失效

```
expires: Thu, 28 Oct 2021 05:24:44 GMT
```

#### Cache-Control

可以设置资源缓存的相对时间，还有其他属性设置

1. `max-age` 表示资源缓存的最大有效时间，这就是一个相对时间,单位是秒
2. `no-cache` 需要进行协商缓存，发送请求到服务器确认是否使用缓存。
3. `no-store` 禁止使用缓存，每一次都要重新请求数据。
4. `public` 默认设置。
5. `private` 不能被多用户共享。
6. 同时设置 `Expire` 和 `Cache-Control` ，`Cache-Control` 的优先级别更高。

```
cache-control: must-revalidate, max-age=31536000
```

## 协商缓存

当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。

协商缓存一般是这样一个流程：

1. 把资源标识，比如 `If-Modify-Since` 或 `Etag` 发送到服务器，确认资源是否更新
2. 如果资源未更新，请求响应返回的 http 状态为 304 并且会显示一个 Not Modified 的字符串，告诉浏览器使用本地缓存;
3. 如果资源已经更新，返回新的数据；
4. 将新数据存入缓存。

#### Last-Modified

浏览器第一次请求资源的时候，服务器返回的 `header` 上会带有一个 `Last-Modified` 字段，表示资源最后修改的时间。

```
Last-Modified: Fri, 27 Oct 2017 07:55:30 GMT
```

当浏览器再次请求该资源时，请求头中会带有一个 `If-Modified-Since` 字段，这个值是第一次请求返回的 `Last-Modified` 的值。服务器收到这个请求后，将 `If-Modified-Since` 和当前的 `Last-Modified` 进行对比。如果相等，则说明资源未修改，返回 304，浏览器使用本地缓存。

**缺点:**

- 最小单位是秒。也就是说如果我短时间内资源发生了改变，Last-Modified 并不会发生变化；
- 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为。

#### Etag

`Etag` 一般是由文件内容 `hash` 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 `Etag` 发生改变。

同样地，在浏览器第一次请求资源时，服务器会返回一个 `Etag` 标识。当再次请求该资源时， 会通过 `If-no-match` 字段将 `Etag` 发送回服务器，然后服务器进行比较，如果相等，则返回 `304` 表示未修改。

**Last-Modified 和 Etag 是可以同时设置的，服务器会优先校验 Etag，如果 Etag 相等就会继续比对 Last-Modified，最后才会决定是否返回 304。**

## 总结

当浏览器再次访问一个已经访问过的资源时，它会这样做：

1. 看看是否命中强缓存，如果命中，就直接使用缓存了；
2. 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；
3. 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存；
4. 否则，返回最新的资源。

[参考文章](https://mp.weixin.qq.com/s/Wvc0lkLpgyEW_u7bbMdvpQ)
